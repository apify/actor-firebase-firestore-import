// Apify SDK - toolkit for building Apify Actors (Read more at https://docs.apify.com/sdk/js/)
import { Actor, log } from 'apify';
import { initializeApp } from 'firebase/app';
import { getFirestore, collection, writeBatch, doc } from 'firebase/firestore/lite';

// Input interface describes shape of input data that actor expects
interface IInput extends Record<string, unknown> {
    apiKey: string;
    authDomain: string;
    projectId: string;
    firestoreCollectionId: string;
    datasetId: string;
    transformFunction?: string;
}

// The init() call configures the Actor for its environment. It's recommended to start every Actor with an init()
await Actor.init();

// Get input of the actor
const input = await Actor.getInput<IInput>();
if (!input) {
    throw new Error('Input is missing!');
}
const { apiKey, authDomain, projectId, firestoreCollectionId, datasetId, transformFunction, customIdField } = input;

// Initialize firebase app
const app = initializeApp({
    apiKey,
    authDomain,
    projectId,
});

// Get Firestore instance
const db = getFirestore(app);

// Open dataset
log.info('Opening dataset', { datasetId });
const dataset = await Actor.openDataset(datasetId, { forceCloud: true });
const datasetInfo = await dataset.getInfo();

// Check if dataset exists and is not empty
if (!datasetInfo || !datasetInfo.itemCount) {
    const message = 'Dataset does not exist or is empty!';
    log.error(message, { datasetId });
    throw new Error(message);
}
const datesetSize = datasetInfo.itemCount;

// Get Firestore collection reference
log.info('Opening Firestore collection', { firestoreCollectionId });
const collectionRef = collection(db, firestoreCollectionId);

// Prepare and check transform function
// eslint-disable-next-line no-eval
const transformFunctionEvaluated = transformFunction && eval(transformFunction);
// Check if transform function is correctly defined
if (transformFunctionEvaluated && typeof transformFunctionEvaluated !== 'function') {
    const message = 'Transform function is not correctly defined! The specification of the transform function is available in the README.';
    log.error(message, { transformFunction });
    throw new Error(message);
}

// 10 log indexes equally distributed across the dataset
const logIndexes = Array.from({ length: 10 }, (_, i) => Math.floor((datesetSize / 10) * (i + 1) - 1));

log.info('Importing items to Firestore collection', { datesetSize });

// start timer
const startTime = Date.now();

// limit to 500 writes per batch because of Firestore writeBatch limits
// (https://firebase.google.com/docs/firestore/manage-data/transactions#batched-writes)
const BATCH_SIZE = 500;

for (let startIndex = 0; startIndex < datesetSize; startIndex += BATCH_SIZE) {
    // create batch
    const batch = writeBatch(db);

    // load batch of items from dataset
    const datasetData = await dataset.getData({
        offset: startIndex,
        limit: BATCH_SIZE,
    });

    // add batch of items to Firestore collection
    for (let offsetIndex = 0; offsetIndex < datasetData.count; offsetIndex++) {
        // get item
        let item = datasetData.items[offsetIndex];

        // get item index
        const itemIndex = startIndex + offsetIndex;

        // apply transform function if defined
        if (transformFunctionEvaluated) {
            item = await transformFunctionEvaluated(item);
        }

        // get doc ref with custom or autogenerated id
        let docRef;
        if (customIdField) {
            const customIdFieldValue = item[customIdField as string];
            if (!customIdFieldValue) {
                const message = `Dataset item does not have filed ${customIdField} defined! It cannot be used as a document id in Firestore.`;
                log.error(message, { item });
                throw new Error(message);
            }
            docRef = doc(collectionRef, customIdFieldValue);
        } else {
            // id will be autogenerated by Firebase
            docRef = doc(collectionRef);
        }

        // add doc to batch
        batch.set(docRef, item);

        // log progress
        if (logIndexes.includes(itemIndex)) {
            const progressPercent = Math.round(((itemIndex + 1) / datesetSize) * 100);
            log.info(`Import progress: ${progressPercent}%`);
        }
    }

    // commit batch
    await batch.commit();
}

// end timer
const endTime = Date.now();
const duration = (endTime - startTime) / 1000;
log.info(`Import to Firebase Firestore finished successfully âœ…`);
log.info(`Imported ${datesetSize} items in ${duration} seconds`);

await Actor.exit();
